
          A
      B       C      
   //先序遍历的顺序：ABC (先根节点A，在左子树B，然后右子树C)；
//中序遍历的顺序：BAC(先左子树B，在根节点A，然后右子树C)；
//后序遍历的顺序：BCA(先左子树B，在右子树C，然后根节点A)。






        
                 A
            B         C
         D    E
中序遍历：
1. 中序遍历的概念
若二叉树为空，则什么也不做；否则：
① 中序遍历左子树；② 访问根节点；③ 中序遍历右子树。
DBEAC

一个将二叉树转换为中序遍历的简单高效的方法：对于中序遍历，我们可以在每个结点的下方画一个小标记，然后从根结点出发，遇到下方标记时，访问对应的结点，该顺序就是中序遍历的访问顺序。


1. 后序遍历的概念
若二叉树为空，则什么也不做；否则：
① 后序遍历左子树；② 后序遍历右子树；③ 访问根节点；（简记为“左右根”）

后序遍历序列为：DEBAC

一个将二叉树转换为后序遍历的简单高效的方法：对于后序遍历，我们可以在每个结点的右边画一个小标记，然后从根结点出发，将小标记依次连接起来，其连接的顺序就是后序遍历的访问顺序。


中序遍历代码演示：
void InOrder(BiTree T){//中序遍历二叉树（递归）
    if(T != NULL){
        InOrder(T->leftChild);//递归遍历左子树
        visit(T);//访问根节点
        InOrder(T->rightChild);//递归遍历右子树
    }
}//设二叉树的结点有n个，则时间复杂度和空间复杂度都为O(n)


后序遍历：
void PostOrder(BiTree T){//后序遍历二叉树（递归）
    if(T != NULL){
        PostOrder(T->leftChild);//递归遍历左子树
        PostOrder(T->rightChild);//递归遍历右子树
        visit(T);//访问根节点
    }
}//设二叉树的结点有n个，则时间复杂度和空间复杂度都为O(n)


